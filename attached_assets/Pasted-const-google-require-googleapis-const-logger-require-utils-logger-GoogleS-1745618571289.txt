const { google } = require('googleapis');
const logger = require('../utils/logger');

/**
 * GoogleSheetsService
 * 
 * Service for interacting with Google Sheets API to store and retrieve
 * order information for the virtual framing application.
 */
class GoogleSheetsService {
  constructor() {
    this.sheets = null;
    this.spreadsheetId = process.env.GOOGLE_SHEET_ID;
    this.initialized = false;
  }

  /**
   * Initialize the Google Sheets API client
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async initialize() {
    try {
      // Check if already initialized
      if (this.initialized) {
        return true;
      }

      // Check for required environment variables
      if (!process.env.GOOGLE_SHEET_ID) {
        throw new Error('GOOGLE_SHEET_ID environment variable is required');
      }

      if (!process.env.GOOGLE_SERVICE_ACCOUNT_KEY) {
        throw new Error('GOOGLE_SERVICE_ACCOUNT_KEY environment variable is required');
      }

      // Parse the service account key
      const serviceAccountKey = JSON.parse(
        Buffer.from(process.env.GOOGLE_SERVICE_ACCOUNT_KEY, 'base64').toString()
      );

      // Create JWT client
      const auth = new google.auth.JWT({
        email: serviceAccountKey.client_email,
        key: serviceAccountKey.private_key,
        scopes: ['https://www.googleapis.com/auth/spreadsheets'],
      });

      // Initialize the sheets API client
      this.sheets = google.sheets({ version: 'v4', auth });
      this.initialized = true;
      
      logger.info('Google Sheets service initialized successfully');
      return true;
    } catch (error) {
      logger.error('Failed to initialize Google Sheets service:', error);
      throw error;
    }
  }

  /**
   * Get all orders from the Google Sheet
   * @returns {Promise<Array>} - Array of order objects
   */
  async getAllOrders() {
    try {
      await this.initialize();

      const response = await this.sheets.spreadsheets.values.get({
        spreadsheetId: this.spreadsheetId,
        range: 'Orders!A2:Z',
      });

      const rows = response.data.values || [];
      const headers = await this._getHeaders('Orders');

      // Map rows to objects using headers
      return rows.map(row => {
        const order = {};
        headers.forEach((header, index) => {
          if (index < row.length) {
            order[header] = row[index];
          } else {
            order[header] = '';
          }
        });
        return order;
      });
    } catch (error) {
      logger.error('Error fetching orders from Google Sheets:', error);
      throw error;
    }
  }

  /**
   * Get an order by its ID
   * @param {string} orderId - The order ID to search for
   * @returns {Promise<Object|null>} - Order object or null if not found
   */
  async getOrderById(orderId) {
    try {
      const orders = await this.getAllOrders();
      return orders.find(order => order.orderId === orderId) || null;
    } catch (error) {
      logger.error(`Error fetching order ${orderId}:`, error);
      throw error;
    }
  }

  /**
   * Get orders by customer email
   * @param {string} email - Customer email to search for
   * @returns {Promise<Array>} - Array of order objects
   */
  async getOrdersByEmail(email) {
    try {
      const orders = await this.getAllOrders();
      return orders.filter(order => order.customerEmail === email);
    } catch (error) {
      logger.error(`Error fetching orders for email ${email}:`, error);
      throw error;
    }
  }

  /**
   * Create a new order in the Google Sheet
   * @param {Object} orderData - Order data to insert
   * @returns {Promise<Object>} - The created order with ID
   */
  async createOrder(orderData) {
    try {
      await this.initialize();
      
      // Get the headers to ensure correct column order
      const headers = await this._getHeaders('Orders');
      
      // Generate a unique order ID
      const orderId = `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      orderData.orderId = orderId;
      
      // Add timestamp
      orderData.orderDate = new Date().toISOString();
      orderData.lastUpdated = new Date().toISOString();
      orderData.status = 'New';
      
      // Prepare row values in the correct order
      const rowValues = headers.map(header => orderData[header] || '');
      
      // Append the new row
      await this.sheets.spreadsheets.values.append({
        spreadsheetId: this.spreadsheetId,
        range: 'Orders!A2:Z',
        valueInputOption: 'RAW',
        insertDataOption: 'INSERT_ROWS',
        resource: {
          values: [rowValues],
        },
      });
      
      logger.info(`New order created with ID: ${orderId}`);
      return orderData;
    } catch (error) {
      logger.error('Error creating order in Google Sheets:', error);
      throw error;
    }
  }

  /**
   * Update an existing order in the Google Sheet
   * @param {string} orderId - The order ID to update
   * @param {Object} updateData - Data to update
   * @returns {Promise<Object>} - The updated order
   */
  async updateOrder(orderId, updateData) {
    try {
      await this.initialize();
      
      // Get all orders to find the row index
      const orders = await this.getAllOrders();
      const orderIndex = orders.findIndex(order => order.orderId === orderId);
      
      if (orderIndex === -1) {
        throw new Error(`Order with ID ${orderId} not found`);
      }
      
      // Get the headers to ensure correct column order
      const headers = await this._getHeaders('Orders');
      
      // Merge the existing order with update data
      const existingOrder = orders[orderIndex];
      const updatedOrder = { ...existingOrder, ...updateData };
      updatedOrder.lastUpdated = new Date().toISOString();
      
      // Prepare row values in the correct order
      const rowValues = headers.map(header => updatedOrder[header] || '');
      
      // Calculate the row number (add 2 because index is 0-based and we skip header row)
      const rowNumber = orderIndex + 2;
      
      // Update the row
      await this.sheets.spreadsheets.values.update({
        spreadsheetId: this.spreadsheetId,
        range: `Orders!A${rowNumber}:Z${rowNumber}`,
        valueInputOption: 'RAW',
        resource: {
          values: [rowValues],
        },
      });
      
      logger.info(`Updated order with ID: ${orderId}`);
      return updatedOrder;
    } catch (error) {
      logger.error(`Error updating order ${orderId}:`, error);
      throw error;
    }
  }

  /**
   * Update the status of an order
   * @param {string} orderId - The order ID
   * @param {string} status - The new status
   * @returns {Promise<Object>} - The updated order
   */
  async updateOrderStatus(orderId, status) {
    return this.updateOrder(orderId, { status });
  }

  /**
   * Get the headers from the first row of a sheet
   * @param {string} sheetName - Name of the sheet
   * @returns {Promise<Array>} - Array of header strings
   * @private
   */
  async _getHeaders(sheetName) {
    try {
      const response = await this.sheets.spreadsheets.values.get({
        spreadsheetId: this.